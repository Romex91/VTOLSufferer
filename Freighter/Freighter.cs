using Sandbox.Game.Entities;
using Sandbox.Game.EntityComponents; using Sandbox.ModAPI.Ingame; using Sandbox.ModAPI.Interfaces; using SpaceEngineers.Game.ModAPI.Ingame; using System; using System.Collections; using System.Collections.Generic; using System.Collections.Immutable; using System.Linq; using System.Text; using VRage; using VRage.Collections; using VRage.Game; using VRage.Game.Components; using VRage.Game.GUI.TextPanel; using VRage.Game.ModAPI.Ingame; using VRage.Game.ModAPI.Ingame.Utilities; using VRage.Game.ObjectBuilders.Definitions; using VRageMath;  namespace IngameScript {     partial class Program : MyGridProgram     {         Display display;         List<IMyGyro> gyros;         List<IMyThrust> thrusters;         IMyShipController controller;         LinearStabilization rollStabilization;         LinearStabilization pitchStabilization;         LinearStabilization thrustStabilization;          float elevationSpeed;         float elevationSpeedPrev;         DateTime prevMeasurementTime = DateTime.Now;          public Program()         {             Runtime.UpdateFrequency = UpdateFrequency.Update1;             gyros = getGyros(this);             thrusters = getThrusters(this);             display = new Display(this);             rollStabilization = new LinearStabilization(0.01f, 0.01f, 0f);             pitchStabilization = new LinearStabilization(0.001f, 0.01f, 0f);             thrustStabilization = new LinearStabilization(0.001f, 0.96f, 0.8f);              controller = getFirstCockpit(this);         }          public void Save()         {          }
         public void Main(string argument, UpdateType updateSource)         {             var worldMatrix = controller.WorldMatrix;              Vector3D planetCenter;             if (!controller.TryGetPlanetPosition(out planetCenter))
            {
                display.log("Planet not found.\nThis is VTOL.\nTurning offline.");
                foreach (var gyro in gyros)
                {
                    gyro.GyroOverride = false;
                }
                return;
            }             var upDirectionGlobal = Vector3D.Normalize(controller.GetPosition() - planetCenter);
            var localUp = Vector3D.TransformNormal(Vector3D.Normalize(upDirectionGlobal), MatrixD.Transpose(worldMatrix));

            Vector3D position = new Vector3D(worldMatrix.M41, worldMatrix.M42, worldMatrix.M43);              Vector3D linearVelocity = Vector3D.TransformNormal(controller.GetShipVelocities().LinearVelocity, MatrixD.Transpose(worldMatrix));             Vector3D angularVelocity = Vector3D.TransformNormal(controller.GetShipVelocities().AngularVelocity, MatrixD.Transpose(worldMatrix));                          float roll = (float)(-Math.Atan2(localUp.X, localUp.Y) * 180 / Math.PI);             float pitch = (float)(Math.Atan2(localUp.Z, localUp.Y) * 180 / Math.PI);               elevationSpeedPrev = elevationSpeed;             elevationSpeed = (float) Vector3D.Dot(localUp, linearVelocity);             DateTime now = DateTime.Now;             float elevationSpeedDelta = (float)((elevationSpeed - elevationSpeedPrev) / (now - prevMeasurementTime).TotalSeconds);             prevMeasurementTime = now;              display.log($"pitch {pitch.ToString("0.00")}\n");             display.log($"roll {roll.ToString("0.00")}\n");              float gyroRoll = AutopilotDerivativesWaterfall.cumputeLastDerivative(controller.MoveIndicator.X * 100, new List<AutopilotDerivativesWaterfall.Derivative>                 {                    new AutopilotDerivativesWaterfall.Derivative { name = "velocity X", maxValue = 100, currentValue = (float)linearVelocity.X },                    new AutopilotDerivativesWaterfall.Derivative { name = "rollAngle", maxValue = 40, currentValue = roll, sensitivityMultiplier = 10f },                    new AutopilotDerivativesWaterfall.Derivative { name = "rollAngularVelocity", maxValue = 1, currentValue = (float) - angularVelocity.Z, sensitivityMultiplier = 20f },                 }, display);               float gyroPitch = AutopilotDerivativesWaterfall.cumputeLastDerivative(-controller.MoveIndicator.Z * 100, new List<AutopilotDerivativesWaterfall.Derivative>                 {                    new AutopilotDerivativesWaterfall.Derivative { name = "velocity Y", maxValue = 100, currentValue = (float)-linearVelocity.Z },                    new AutopilotDerivativesWaterfall.Derivative { name = "pitch", maxValue = 40, currentValue = pitch, sensitivityMultiplier = 10f },                    new AutopilotDerivativesWaterfall.Derivative { name = "pitchAngularVelocity", maxValue = 1, currentValue = (float) - angularVelocity.X, sensitivityMultiplier = 20f },                 });              float desiredElevationSpeedDelta = AutopilotDerivativesWaterfall.cumputeLastDerivative(controller.MoveIndicator.Y * 100, new List<AutopilotDerivativesWaterfall.Derivative>             {                 new AutopilotDerivativesWaterfall.Derivative { name = "velocity Z", maxValue = 50, currentValue = (float)elevationSpeed, sensitivityMultiplier = 1f },             }) * 10;              double G = controller.GetNaturalGravity().Length();             double shipMass = controller.CalculateShipMass().TotalMass;
            display.log($"G {G.ToString("0.000")} \n");
            display.log($"shipMass {shipMass.ToString("0.000")} \n");              float forcePerThruster = (float)(shipMass * (G + desiredElevationSpeedDelta)) / thrusters.Count;             float thrustValue = thrustStabilization.adjustValue(forcePerThruster, desiredElevationSpeedDelta, elevationSpeedDelta, this);

            display.log($"forcePerThruster {forcePerThruster.ToString("0.000")} \n");             display.log($"thrustValue {thrustValue.ToString("0.000")}\ndesiredElevationSpeedDelta {desiredElevationSpeedDelta.ToString("0.000")} \n");             display.log($"elevationSpeedDelta {elevationSpeedDelta.ToString("0.000")} \n");              thrustValue = (float)((thrustValue + 1) / Math.Cos(pitch / 180 * Math.PI));              display.log($"thrustValue {thrustValue.ToString("0.000")} \n");              foreach (var thruster in thrusters)             {                 thruster.ThrustOverride = thrustValue;             }              foreach (var gyro in gyros)             {                 gyro.GyroOverride = true;                 gyro.Yaw = controller.RotationIndicator.Y;                 gyro.Pitch = gyroPitch;                 gyro.Roll = gyroRoll;             }              display.flush();         }     } } 